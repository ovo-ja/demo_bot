<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Martingale Over/Under Bot</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #111827;
            --bg-tertiary: #1f2937;
            --accent-green: #10b981;
            --accent-green-dim: #065f46;
            --accent-red: #ef4444;
            --accent-red-dim: #7f1d1d;
            --accent-blue: #3b82f6;
            --accent-yellow: #f59e0b;
            --accent-purple: #8b5cf6;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --text-dim: #6b7280;
            --border-color: #374151;
        }
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-green) 0%, var(--accent-blue) 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 18px;
        }
        
        .logo h1 {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .logo span {
            color: var(--accent-green);
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-red);
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: var(--accent-green);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .reconnect-count {
            color: var(--accent-yellow);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 320px 1fr 350px;
            gap: 20px;
        }
        
        .panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        
        .panel-header {
            padding: 16px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 0.95rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .panel-content {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-green) 0%, #059669 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, var(--accent-red) 0%, #dc2626 100%);
            color: white;
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: var(--bg-tertiary);
            padding: 16px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-card.full-width {
            grid-column: span 2;
        }
        
        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .stat-value.profit {
            color: var(--accent-green);
        }
        
        .stat-value.loss {
            color: var(--accent-red);
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .phase-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: 16px;
        }
        
        .phase-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .phase-badge.observation {
            background: var(--accent-blue);
            color: white;
        }
        
        .phase-badge.analyzing {
            background: var(--accent-purple);
            color: white;
        }
        
        .phase-badge.trading {
            background: var(--accent-green);
            color: white;
        }
        
        .phase-badge.recovery {
            background: var(--accent-red);
            color: white;
        }
        
        .phase-badge.idle {
            background: var(--text-dim);
            color: white;
        }
        
        .martingale-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }
        
        .martingale-table th, .martingale-table td {
            padding: 8px 10px;
            text-align: right;
            border-bottom: 1px solid var(--border-color);
        }
        
        .martingale-table th {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.7rem;
            text-transform: uppercase;
        }
        
        .martingale-table tr.active {
            background: rgba(59, 130, 246, 0.2);
        }
        
        .martingale-table tr.active td {
            color: var(--accent-blue);
            font-weight: 600;
        }
        
        .digit-distribution {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            margin-bottom: 16px;
        }
        
        .digit-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .digit-bar-fill {
            width: 100%;
            height: 60px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .digit-bar-inner {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: var(--accent-blue);
            transition: height 0.3s;
            border-radius: 4px;
        }
        
        .digit-bar-inner.low {
            background: var(--accent-red);
        }
        
        .digit-bar-inner.high {
            background: var(--accent-green);
        }
        
        .digit-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .digit-percent {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-dim);
        }
        
        .trend-indicators {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .trend-card {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .trend-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .trend-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .log-container {
            height: 300px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 12px;
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 8px;
        }
        
        .log-time {
            color: var(--text-dim);
            min-width: 70px;
        }
        
        .log-type {
            min-width: 60px;
            font-weight: 600;
        }
        
        .log-type.info { color: var(--accent-blue); }
        .log-type.trade { color: var(--accent-green); }
        .log-type.loss { color: var(--accent-red); }
        .log-type.signal { color: var(--accent-purple); }
        .log-type.system { color: var(--accent-yellow); }
        
        .log-message {
            color: var(--text-secondary);
            flex: 1;
        }
        
        .tick-display {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: 16px;
        }
        
        .current-digit {
            width: 60px;
            height: 60px;
            background: var(--bg-primary);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
        }
        
        .current-digit.low { color: var(--accent-red); }
        .current-digit.high { color: var(--accent-green); }
        
        .tick-info {
            flex: 1;
        }
        
        .tick-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .tick-count {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .signal-display {
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            text-align: center;
            margin-bottom: 16px;
        }
        
        .signal-direction {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .signal-direction.over { color: var(--accent-green); }
        .signal-direction.under { color: var(--accent-red); }
        .signal-direction.none { color: var(--text-dim); }
        
        .signal-confidence {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .export-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 16px;
        }
        
        .export-buttons .btn {
            padding: 10px;
            font-size: 0.8rem;
        }
        
        .recent-digits {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }
        
        .recent-digit {
            width: 28px;
            height: 28px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .recent-digit.low { background: var(--accent-red-dim); color: var(--accent-red); }
        .recent-digit.high { background: var(--accent-green-dim); color: var(--accent-green); }
        
        .trade-history {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .trade-entry {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }
        
        .trade-entry.win { border-left: 3px solid var(--accent-green); }
        .trade-entry.loss { border-left: 3px solid var(--accent-red); }
        
        .strategy-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .strategy-btn {
            flex: 1;
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .strategy-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .progress-bar {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent-blue);
            transition: width 0.3s;
        }
        
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">M+</div>
                <h1>Hybrid <span>Martingale</span> Bot</h1>
            </div>
            <div class="connection-status">
                <div class="status-indicator" style="background: linear-gradient(135deg, var(--accent-green-dim) 0%, var(--bg-tertiary) 100%); border: 1px solid var(--accent-green);">
                    <span style="color: var(--text-secondary);">Balance:</span>
                    <span style="color: var(--accent-green); font-weight: 700; font-size: 1.1rem;" id="accountBalance">$0.00</span>
                </div>
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <div class="status-indicator">
                    <span>Reconnects: </span>
                    <span class="reconnect-count" id="reconnectCount">0</span>
                </div>
            </div>
        </header>
        
        <div class="main-grid">
            <!-- Left Panel - Controls -->
            <div class="panel">
                <div class="panel-header">Trading Configuration</div>
                <div class="panel-content">
                    <div class="form-group">
                        <label>API Token</label>
                        <input type="password" id="apiToken" placeholder="Enter your Deriv API token">
                    </div>
                    
                    <div class="form-group">
                        <label>Market</label>
                        <select id="market">
                            <option value="R_10">Volatility 10 Index</option>
                            <option value="R_25">Volatility 25 Index</option>
                            <option value="R_50">Volatility 50 Index</option>
                            <option value="R_75">Volatility 75 Index</option>
                            <option value="R_100">Volatility 100 Index</option>
                            <option value="1HZ10V">Volatility 10 (1s) Index</option>
                            <option value="1HZ25V">Volatility 25 (1s) Index</option>
                            <option value="1HZ50V">Volatility 50 (1s) Index</option>
                            <option value="1HZ75V">Volatility 75 (1s) Index</option>
                            <option value="1HZ100V">Volatility 100 (1s) Index</option>
                        </select>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label>Base Stake ($)</label>
                            <input type="number" id="baseStake" value="0.35" min="0.35" step="0.01">
                        </div>
                        <div class="form-group">
                            <label>Payout (%)</label>
                            <input type="number" id="payout" value="95" min="80" max="100" step="1">
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label>Max Martingale Depth</label>
                            <input type="number" id="maxDepth" value="10" min="1" max="15">
                        </div>
                        <div class="form-group">
                            <label>Observation Ticks</label>
                            <input type="number" id="observationTicks" value="100" min="10" max="500" step="10">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Entry Strategy</label>
                        <div class="strategy-toggle">
                            <button class="strategy-btn" data-strategy="reversal" id="btnReversal">Reversal</button>
                            <button class="strategy-btn active" data-strategy="trend" id="btnTrend">Trend</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Consecutive Trigger</label>
                        <input type="number" id="consecutiveTrigger" value="6" min="2" max="10">
                        <small style="color: var(--text-dim); font-size: 0.75rem;">Consecutive digits before signal</small>
                    </div>
                    
                    <div class="form-group">
                        <label>Stop Loss ($)</label>
                        <input type="number" id="stopLoss" value="0" min="0" step="10" placeholder="0 = disabled">
                    </div>
                    
                    <div class="form-group">
                        <label>Take Profit ($)</label>
                        <input type="number" id="takeProfit" value="0" min="0" step="10" placeholder="0 = disabled">
                    </div>
                    
                    <button class="btn btn-primary" id="btnStart">
                        <span>‚ñ∂</span> Start Bot
                    </button>
                    <button class="btn btn-danger" id="btnStop" style="display: none; margin-top: 10px;">
                        <span>‚ñ†</span> Stop Bot
                    </button>
                    <button class="btn btn-secondary" id="btnWatch" style="margin-top: 10px;">
                        <span>üëÅ</span> Watch Only (Shadow)
                    </button>
                    <button class="btn btn-secondary" id="btnStopWatch" style="display: none; margin-top: 10px;">
                        <span>‚ñ†</span> Stop Watching
                    </button>
                    
                    <div class="export-buttons">
                        <button class="btn btn-secondary" id="btnExportTicks">Ticks CSV</button>
                        <button class="btn btn-secondary" id="btnExportTrades">Trades CSV</button>
                        <button class="btn btn-secondary" id="btnExportLog">Log CSV</button>
                    </div>
                </div>
            </div>
            
            <!-- Center Panel - Main Display -->
            <div style="display: flex; flex-direction: column; gap: 20px;">
                <!-- Phase & Stats -->
                <div class="panel">
                    <div class="panel-header">
                        <span>Trading Status</span>
                        <div class="phase-badge idle" id="phaseBadge">IDLE</div>
                    </div>
                    <div class="panel-content">
                        <div class="phase-indicator">
                            <div>
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Observation Progress</div>
                                <div style="font-family: 'JetBrains Mono', monospace; font-size: 1.1rem;" id="observationProgress">0 / 100</div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="tick-display">
                            <div class="current-digit" id="currentDigit">-</div>
                            <div class="tick-info">
                                <div class="tick-price" id="tickPrice">0.00000</div>
                                <div class="tick-count">Tick #<span id="tickCount">0</span></div>
                            </div>
                        </div>
                        
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-value" id="totalTrades">0</div>
                                <div class="stat-label">Total Trades</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="winRate">0%</div>
                                <div class="stat-label">Win Rate</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="wins">0</div>
                                <div class="stat-label">Wins</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="losses">0</div>
                                <div class="stat-label">Losses</div>
                            </div>
                            <div class="stat-card full-width">
                                <div class="stat-value profit" id="profitLoss">$0.00</div>
                                <div class="stat-label">Profit / Loss</div>
                            </div>
                        </div>
                        
                        <div class="signal-display">
                            <div class="signal-direction none" id="signalDirection">WAITING</div>
                            <div class="signal-confidence" id="signalConfidence">Collecting data...</div>
                        </div>
                        
                        <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 8px;">Recent Digits (Last 30)</div>
                        <div class="recent-digits" id="recentDigits"></div>
                    </div>
                </div>
                
                <!-- Pattern Analysis -->
                <div class="panel">
                    <div class="panel-header">Pattern Analysis</div>
                    <div class="panel-content">
                        <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 8px;">Digit Distribution</div>
                        <div class="digit-distribution" id="digitDistribution">
                            <!-- Generated by JS -->
                        </div>
                        
                        <div class="trend-indicators">
                            <div class="trend-card">
                                <div class="trend-value" id="lowPercent">50%</div>
                                <div class="trend-label">Low (0-4)</div>
                            </div>
                            <div class="trend-card">
                                <div class="trend-value" id="highPercent">50%</div>
                                <div class="trend-label">High (5-9)</div>
                            </div>
                            <div class="trend-card">
                                <div class="trend-value" id="consecutiveLow">0</div>
                                <div class="trend-label">Consec. Low</div>
                            </div>
                            <div class="trend-card">
                                <div class="trend-value" id="consecutiveHigh">0</div>
                                <div class="trend-label">Consec. High</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Activity Log -->
                <div class="panel">
                    <div class="panel-header">
                        <span>Activity Log</span>
                        <button class="btn btn-secondary" style="width: auto; padding: 6px 12px; font-size: 0.75rem;" id="btnClearLog">Clear</button>
                    </div>
                    <div class="panel-content">
                        <div class="log-container" id="logContainer"></div>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel - Martingale & Trades -->
            <div style="display: flex; flex-direction: column; gap: 20px;">
                <!-- Shadow Tracker Panel -->
                <div class="panel">
                    <div class="panel-header">
                        <span>Shadow Tracker</span>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 0.75rem; cursor: pointer;">
                            <input type="checkbox" id="shadowEnabled" checked style="cursor: pointer;">
                            Active
                        </label>
                    </div>
                    <div class="panel-content">
                        <div id="shadowRecommendation" style="padding: 12px; border-radius: 8px; text-align: center; margin-bottom: 12px; background: var(--bg-tertiary);">
                            <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 4px;">RECOMMENDATION</div>
                            <div id="shadowRecommendText" style="font-size: 1.1rem; font-weight: 700; color: var(--text-dim);">WAITING...</div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
                            <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; text-align: center;">
                                <div style="font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; font-weight: 700; color: var(--accent-green);" id="shadowWins">0</div>
                                <div style="font-size: 0.65rem; color: var(--text-secondary);">WINS</div>
                            </div>
                            <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; text-align: center;">
                                <div style="font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; font-weight: 700; color: var(--accent-red);" id="shadowLosses">0</div>
                                <div style="font-size: 0.65rem; color: var(--text-secondary);">LOSSES</div>
                            </div>
                            <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; text-align: center;">
                                <div style="font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; font-weight: 700;" id="shadowDiff">0</div>
                                <div style="font-size: 0.65rem; color: var(--text-secondary);">DIFF</div>
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 6px;">
                                <span style="color: var(--text-secondary);">Last Signal:</span>
                                <span id="shadowLastSignal" style="font-family: 'JetBrains Mono', monospace;">-</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.8rem;">
                                <span style="color: var(--text-secondary);">Would Have:</span>
                                <span id="shadowLastResult" style="font-family: 'JetBrains Mono', monospace;">-</span>
                            </div>
                        </div>
                        
                        <button class="btn btn-secondary" id="btnResetShadow" style="margin-bottom: 12px;">Reset Shadow Tracker</button>
                        
                        <!-- Streak Tracking Section -->
                        <div style="border-top: 1px solid var(--border-color); padding-top: 12px; margin-bottom: 12px;">
                            <div style="font-weight: 600; font-size: 0.85rem; margin-bottom: 8px;">Loss Streak Monitor</div>
                            
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 10px;">
                                <div style="background: var(--bg-tertiary); padding: 8px; border-radius: 6px; text-align: center;">
                                    <div style="font-family: 'JetBrains Mono', monospace; font-size: 1rem; font-weight: 700;" id="currentLossStreak">0</div>
                                    <div style="font-size: 0.6rem; color: var(--text-secondary);">CURRENT STREAK</div>
                                </div>
                                <div style="background: var(--bg-tertiary); padding: 8px; border-radius: 6px; text-align: center;">
                                    <div style="font-family: 'JetBrains Mono', monospace; font-size: 1rem; font-weight: 700; color: var(--accent-red);" id="maxLossStreak">0</div>
                                    <div style="font-size: 0.6rem; color: var(--text-secondary);">MAX STREAK</div>
                                </div>
                            </div>
                            
                            <div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; font-size: 0.75rem; margin-bottom: 4px;">
                                    <span style="color: var(--text-secondary);">Cycles Completed:</span>
                                    <span style="font-family: 'JetBrains Mono', monospace;" id="cyclesCompleted">0</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; font-size: 0.75rem; margin-bottom: 4px;">
                                    <span style="color: var(--text-secondary);">4+ Loss Streaks:</span>
                                    <span style="font-family: 'JetBrains Mono', monospace; color: var(--accent-red);" id="fourPlusStreaks">0</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; font-size: 0.75rem;">
                                    <span style="color: var(--text-secondary);">Streak Rate:</span>
                                    <span style="font-family: 'JetBrains Mono', monospace;" id="streakRate">0%</span>
                                </div>
                            </div>
                            
                            <!-- Adaptive Trigger -->
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 0.8rem;">Adaptive Trigger</span>
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                    <input type="checkbox" id="adaptiveTriggerEnabled" style="cursor: pointer;">
                                    <span style="font-size: 0.75rem;">Enable</span>
                                </label>
                            </div>
                            
                            <div id="adaptiveTriggerStatus" style="padding: 8px; border-radius: 6px; text-align: center; font-size: 0.75rem; background: var(--bg-tertiary); color: var(--text-dim);">
                                Adaptive: OFF | Trigger: <span id="currentTriggerDisplay">6</span>
                            </div>
                        </div>
                        
                        <!-- Autopilot Section -->
                        <div style="border-top: 1px solid var(--border-color); padding-top: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <span style="font-weight: 600; font-size: 0.9rem;">Autopilot Mode</span>
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                    <input type="checkbox" id="autopilotEnabled" style="cursor: pointer;">
                                    <span style="font-size: 0.8rem;">Enable</span>
                                </label>
                            </div>
                            
                            <div class="form-row" style="margin-bottom: 8px;">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label style="font-size: 0.7rem;">Exit at Diff +</label>
                                    <input type="number" id="exitThreshold" value="5" min="3" max="10" style="padding: 6px 10px;">
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label style="font-size: 0.7rem;">Enter at Diff -</label>
                                    <input type="number" id="entryThreshold" value="3" min="0" max="10" style="padding: 6px 10px;">
                                </div>
                            </div>
                            
                            <div id="autopilotStatus" style="padding: 10px; border-radius: 6px; text-align: center; font-size: 0.8rem; background: var(--bg-tertiary); color: var(--text-dim);">
                                Autopilot Disabled
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <div class="panel-header">
                        <span>Martingale Progression</span>
                        <span style="font-size: 0.75rem; color: var(--text-secondary);">Level: <span id="currentLevel">0</span></span>
                    </div>
                    <div class="panel-content">
                        <table class="martingale-table" id="martingaleTable">
                            <thead>
                                <tr>
                                    <th>Lvl</th>
                                    <th>Stake</th>
                                    <th>Total Risk</th>
                                    <th>Win Profit</th>
                                </tr>
                            </thead>
                            <tbody id="martingaleBody">
                                <!-- Generated by JS -->
                            </tbody>
                        </table>
                        <div style="margin-top: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.8rem;">
                                <span style="color: var(--text-secondary);">Max Risk:</span>
                                <span style="font-family: 'JetBrains Mono', monospace; color: var(--accent-red);" id="maxRisk">$0.00</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.8rem; margin-top: 6px;">
                                <span style="color: var(--text-secondary);">Current Stake:</span>
                                <span style="font-family: 'JetBrains Mono', monospace; color: var(--accent-blue);" id="currentStake">$0.35</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <div class="panel-header">Trade History</div>
                    <div class="panel-content">
                        <div class="trade-history" id="tradeHistory">
                            <div style="text-align: center; color: var(--text-dim); padding: 20px;">No trades yet</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // STATE MANAGEMENT
        // ========================================
        const state = {
            // Connection
            ws: null,
            connected: false,
            reconnectAttempts: 0,
            reconnectTimer: null,
            keepAliveInterval: null,
            lastPingTime: null,
            
            // Trading
            isRunning: false,
            phase: 'idle', // idle, observation, analyzing, trading, recovery
            currentDirection: null, // 'over' or 'under'
            martingaleLevel: 0,
            
            // Shadow Tracker
            shadow: {
                enabled: true,
                wins: 0,
                losses: 0,
                diff: 0,
                consecutiveLow: 0,
                consecutiveHigh: 0,
                lastSignal: null,
                lastResult: null,
                inSimRecovery: false,
                simDirection: null,
                simLevel: 0,
                history: [],
                
                // Streak tracking
                currentLossStreak: 0,
                maxLossStreak: 0,
                cyclesCompleted: 0,
                fourPlusStreaks: 0,
                streakHistory: [],  // Track last 50 cycles
                
                // Adaptive trigger
                adaptiveTrigger: {
                    enabled: false,
                    baseTrigger: 6,
                    currentTrigger: 6,
                    maxTrigger: 10,
                    checkWindow: 50,      // Check over last 50 cycles
                    maxStreakRate: 3,     // Max 3% of cycles can hit 4+ losses
                    adjustments: 0        // How many times we've adjusted
                }
            },
            
            // Autopilot
            autopilot: {
                enabled: false,
                exitThreshold: 5,    // Exit when diff >= +5
                entryThreshold: -3,  // Enter when diff <= -3
                isPaused: false,     // Paused by autopilot (waiting for good entry)
                pauseReason: ''
            },
            
            // Watch only mode (no trading, just shadow tracking)
            isWatching: false,
            
            // Data
            ticks: [],
            digits: [],
            digitCounts: [0,0,0,0,0,0,0,0,0,0],
            trades: [],
            activityLog: [],
            
            // Stats
            totalTrades: 0,
            wins: 0,
            losses: 0,
            profitLoss: 0,
            
            // Pattern
            consecutiveLow: 0,
            consecutiveHigh: 0,
            
            // Config
            config: {
                apiToken: '',
                market: 'R_10',
                baseStake: 0.35,
                payout: 95,
                maxDepth: 10,
                observationTicks: 100,
                strategy: 'trend',
                consecutiveTrigger: 6,
                stopLoss: 0,
                takeProfit: 0
            },
            
            // Contract tracking
            currentContractId: null,
            pendingTrade: null
        };

        // ========================================
        // DOM ELEMENTS
        // ========================================
        const elements = {
            statusDot: document.getElementById('statusDot'),
            statusText: document.getElementById('statusText'),
            reconnectCount: document.getElementById('reconnectCount'),
            accountBalance: document.getElementById('accountBalance'),
            btnStart: document.getElementById('btnStart'),
            btnStop: document.getElementById('btnStop'),
            phaseBadge: document.getElementById('phaseBadge'),
            observationProgress: document.getElementById('observationProgress'),
            progressFill: document.getElementById('progressFill'),
            currentDigit: document.getElementById('currentDigit'),
            tickPrice: document.getElementById('tickPrice'),
            tickCount: document.getElementById('tickCount'),
            totalTrades: document.getElementById('totalTrades'),
            winRate: document.getElementById('winRate'),
            wins: document.getElementById('wins'),
            losses: document.getElementById('losses'),
            profitLoss: document.getElementById('profitLoss'),
            signalDirection: document.getElementById('signalDirection'),
            signalConfidence: document.getElementById('signalConfidence'),
            recentDigits: document.getElementById('recentDigits'),
            digitDistribution: document.getElementById('digitDistribution'),
            lowPercent: document.getElementById('lowPercent'),
            highPercent: document.getElementById('highPercent'),
            consecutiveLow: document.getElementById('consecutiveLow'),
            consecutiveHigh: document.getElementById('consecutiveHigh'),
            martingaleBody: document.getElementById('martingaleBody'),
            currentLevel: document.getElementById('currentLevel'),
            maxRisk: document.getElementById('maxRisk'),
            currentStake: document.getElementById('currentStake'),
            tradeHistory: document.getElementById('tradeHistory'),
            logContainer: document.getElementById('logContainer')
        };

        // ========================================
        // INDEXEDDB FOR PERSISTENCE
        // ========================================
        let db = null;
        
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('MartingaleBot', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains('ticks')) {
                        database.createObjectStore('ticks', { keyPath: 'id', autoIncrement: true });
                    }
                    if (!database.objectStoreNames.contains('trades')) {
                        database.createObjectStore('trades', { keyPath: 'id', autoIncrement: true });
                    }
                    if (!database.objectStoreNames.contains('state')) {
                        database.createObjectStore('state', { keyPath: 'key' });
                    }
                };
            });
        }
        
        async function saveToDB(store, data) {
            if (!db) return;
            return new Promise((resolve, reject) => {
                const tx = db.transaction(store, 'readwrite');
                const objectStore = tx.objectStore(store);
                const request = objectStore.add(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function saveState() {
            if (!db) return;
            const tx = db.transaction('state', 'readwrite');
            const store = tx.objectStore('state');
            store.put({ key: 'appState', value: {
                profitLoss: state.profitLoss,
                wins: state.wins,
                losses: state.losses,
                totalTrades: state.totalTrades
            }});
        }

        // ========================================
        // LOGGING
        // ========================================
        function log(type, message) {
            const now = new Date();
            const time = now.toTimeString().slice(0, 8);
            const entry = { time, type, message, timestamp: now.toISOString() };
            
            state.activityLog.push(entry);
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `
                <span class="log-time">${time}</span>
                <span class="log-type ${type}">${type.toUpperCase()}</span>
                <span class="log-message">${message}</span>
            `;
            
            elements.logContainer.insertBefore(logEntry, elements.logContainer.firstChild);
            
            // Keep only last 200 entries in DOM
            while (elements.logContainer.children.length > 200) {
                elements.logContainer.removeChild(elements.logContainer.lastChild);
            }
        }

        // ========================================
        // WEBSOCKET CONNECTION
        // ========================================
        function connect() {
            if (state.ws && state.ws.readyState === WebSocket.OPEN) return;
            
            log('system', 'Connecting to Deriv API...');
            state.ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');
            
            state.ws.onopen = () => {
                state.connected = true;
                state.reconnectAttempts = 0;
                updateConnectionStatus(true);
                log('system', 'Connected to Deriv API');
                
                // Authorize if token exists
                if (state.config.apiToken) {
                    authorize();
                }
                
                // Start keep-alive
                startKeepAlive();
            };
            
            state.ws.onclose = () => {
                state.connected = false;
                updateConnectionStatus(false);
                log('system', 'Disconnected from Deriv API');
                
                stopKeepAlive();
                scheduleReconnect();
            };
            
            state.ws.onerror = (error) => {
                log('system', 'WebSocket error occurred');
                console.error('WebSocket error:', error);
            };
            
            state.ws.onmessage = (event) => {
                handleMessage(JSON.parse(event.data));
            };
        }
        
        function authorize() {
            send({ authorize: state.config.apiToken });
        }
        
        function send(data) {
            if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                state.ws.send(JSON.stringify(data));
            }
        }
        
        function updateConnectionStatus(connected) {
            elements.statusDot.classList.toggle('connected', connected);
            elements.statusText.textContent = connected ? 'Connected' : 'Disconnected';
        }
        
        function updateBalance(balanceData) {
            const balance = parseFloat(balanceData.balance).toFixed(2);
            const currency = balanceData.currency || 'USD';
            elements.accountBalance.textContent = `$${balance}`;
            log('info', `Balance updated: $${balance} ${currency}`);
        }
        
        function scheduleReconnect() {
            if (state.reconnectTimer) return;
            
            const delay = Math.min(1000 * Math.pow(2, state.reconnectAttempts), 30000);
            state.reconnectAttempts++;
            elements.reconnectCount.textContent = state.reconnectAttempts;
            
            log('system', `Reconnecting in ${delay/1000}s (attempt ${state.reconnectAttempts})`);
            
            state.reconnectTimer = setTimeout(() => {
                state.reconnectTimer = null;
                connect();
            }, delay);
        }
        
        function startKeepAlive() {
            stopKeepAlive();
            state.keepAliveInterval = setInterval(() => {
                if (state.connected) {
                    send({ ping: 1 });
                    state.lastPingTime = Date.now();
                    
                    // Check for stale connection
                    setTimeout(() => {
                        if (state.lastPingTime && Date.now() - state.lastPingTime > 20000) {
                            log('system', 'Stale connection detected, reconnecting...');
                            state.ws.close();
                        }
                    }, 15000);
                }
            }, 15000);
        }
        
        function stopKeepAlive() {
            if (state.keepAliveInterval) {
                clearInterval(state.keepAliveInterval);
                state.keepAliveInterval = null;
            }
        }

        // ========================================
        // MESSAGE HANDLER
        // ========================================
        function handleMessage(data) {
            if (data.error) {
                log('system', `Error: ${data.error.message}`);
                return;
            }
            
            if (data.msg_type === 'authorize') {
                log('system', 'Authorization successful');
                // Subscribe to balance updates
                send({ balance: 1, subscribe: 1 });
                subscribeToTicks();
            }
            
            if (data.msg_type === 'balance') {
                updateBalance(data.balance);
            }
            
            if (data.msg_type === 'tick') {
                handleTick(data.tick);
            }
            
            if (data.msg_type === 'buy') {
                handleBuyResponse(data);
            }
            
            if (data.msg_type === 'proposal_open_contract') {
                handleContractUpdate(data.proposal_open_contract);
            }
            
            if (data.msg_type === 'ping') {
                state.lastPingTime = null; // Reset stale detection
            }
        }
        
        function subscribeToTicks() {
            send({
                ticks: state.config.market,
                subscribe: 1
            });
            log('info', `Subscribed to ${state.config.market}`);
        }
        
        function handleTick(tick) {
            const price = parseFloat(tick.quote);
            const digit = parseInt(price.toString().slice(-1));
            const timestamp = new Date(tick.epoch * 1000).toISOString();
            
            // Store tick data
            const tickData = { timestamp, price, digit, epoch: tick.epoch };
            state.ticks.push(tickData);
            saveToDB('ticks', tickData);
            
            // Keep only last 5000 ticks in memory
            if (state.ticks.length > 5000) {
                state.ticks.shift();
            }
            
            // Update digits
            state.digits.push(digit);
            state.digitCounts[digit]++;
            
            // Keep only relevant digits in memory
            if (state.digits.length > 1000) {
                const removed = state.digits.shift();
                state.digitCounts[removed]--;
            }
            
            // Update consecutive counters
            if (digit <= 4) {
                state.consecutiveLow++;
                state.consecutiveHigh = 0;
            } else {
                state.consecutiveHigh++;
                state.consecutiveLow = 0;
            }
            
            // Update UI
            updateTickDisplay(price, digit);
            updateDigitDistribution();
            updateRecentDigits();
            updateTrendIndicators();
            
            // Process trading logic
            if (state.isRunning) {
                processTrading(digit);
            }
            
            // Always process shadow tracker (even when bot is off)
            if (state.shadow.enabled) {
                processShadowTracker(digit);
            }
        }
        
        function processShadowTracker(digit) {
            // Update shadow consecutive counters
            if (digit <= 4) {
                state.shadow.consecutiveLow++;
                state.shadow.consecutiveHigh = 0;
            } else {
                state.shadow.consecutiveHigh++;
                state.shadow.consecutiveLow = 0;
            }
            
            // Need enough data
            if (state.digits.length < state.config.observationTicks) {
                updateShadowUI();
                return;
            }
            
            const trigger = state.config.consecutiveTrigger;
            const strategy = state.config.strategy;
            
            let signalDirection = null;
            
            // Check for signal (same logic as real trading)
            if (state.shadow.inSimRecovery) {
                // In simulated recovery - check for signal in same direction
                const dir = state.shadow.simDirection;
                if (strategy === 'trend') {
                    if (dir === 'over' && state.shadow.consecutiveHigh >= trigger) {
                        signalDirection = 'over';
                    } else if (dir === 'under' && state.shadow.consecutiveLow >= trigger) {
                        signalDirection = 'under';
                    }
                } else {
                    if (dir === 'over' && state.shadow.consecutiveLow >= trigger) {
                        signalDirection = 'over';
                    } else if (dir === 'under' && state.shadow.consecutiveHigh >= trigger) {
                        signalDirection = 'under';
                    }
                }
            } else {
                // Look for new signal
                if (strategy === 'trend') {
                    if (state.shadow.consecutiveLow >= trigger) {
                        signalDirection = 'under';
                    } else if (state.shadow.consecutiveHigh >= trigger) {
                        signalDirection = 'over';
                    }
                } else {
                    if (state.shadow.consecutiveLow >= trigger) {
                        signalDirection = 'over';
                    } else if (state.shadow.consecutiveHigh >= trigger) {
                        signalDirection = 'under';
                    }
                }
            }
            
            // If we have a signal, simulate the trade result with NEXT digit
            if (signalDirection && state.shadow.lastSignal !== signalDirection + '_' + state.digits.length) {
                state.shadow.lastSignal = signalDirection;
                
                // Store for next tick evaluation
                state.shadow.pendingSignal = {
                    direction: signalDirection,
                    tickIndex: state.digits.length
                };
            }
            
            // Evaluate previous pending signal
            if (state.shadow.pendingEval) {
                const evalSignal = state.shadow.pendingEval;
                const won = (evalSignal.direction === 'over' && digit >= 5) || 
                           (evalSignal.direction === 'under' && digit <= 4);
                
                if (won) {
                    state.shadow.wins++;
                    state.shadow.lastResult = 'WON ‚úì';
                    
                    // Record streak for this cycle
                    const streakForCycle = state.shadow.currentLossStreak;
                    state.shadow.streakHistory.push(streakForCycle);
                    
                    // Keep only last 50 cycles
                    if (state.shadow.streakHistory.length > 50) {
                        state.shadow.streakHistory.shift();
                    }
                    
                    // Update 4+ streak counter
                    if (streakForCycle >= 4) {
                        state.shadow.fourPlusStreaks++;
                    }
                    
                    state.shadow.cyclesCompleted++;
                    state.shadow.currentLossStreak = 0;
                    state.shadow.inSimRecovery = false;
                    state.shadow.simDirection = null;
                    state.shadow.simLevel = 0;
                    
                    // Check adaptive trigger
                    checkAdaptiveTrigger();
                    
                } else {
                    state.shadow.losses++;
                    state.shadow.lastResult = 'LOST ‚úó';
                    state.shadow.currentLossStreak++;
                    
                    // Update max streak
                    if (state.shadow.currentLossStreak > state.shadow.maxLossStreak) {
                        state.shadow.maxLossStreak = state.shadow.currentLossStreak;
                    }
                    
                    state.shadow.inSimRecovery = true;
                    state.shadow.simDirection = evalSignal.direction;
                    state.shadow.simLevel++;
                    
                    // Check if bust (max depth)
                    if (state.shadow.simLevel >= state.config.maxDepth) {
                        // Record streak for this busted cycle
                        const streakForCycle = state.shadow.currentLossStreak;
                        state.shadow.streakHistory.push(streakForCycle);
                        
                        if (state.shadow.streakHistory.length > 50) {
                            state.shadow.streakHistory.shift();
                        }
                        
                        if (streakForCycle >= 4) {
                            state.shadow.fourPlusStreaks++;
                        }
                        
                        state.shadow.cyclesCompleted++;
                        state.shadow.currentLossStreak = 0;
                        state.shadow.inSimRecovery = false;
                        state.shadow.simDirection = null;
                        state.shadow.simLevel = 0;
                        
                        // Check adaptive trigger
                        checkAdaptiveTrigger();
                    }
                }
                
                state.shadow.diff = state.shadow.wins - state.shadow.losses;
                state.shadow.history.push({
                    direction: evalSignal.direction,
                    won: won,
                    diff: state.shadow.diff
                });
                
                state.shadow.pendingEval = null;
                
                // Check autopilot conditions
                checkAutopilot(won);
            }
            
            // Move pending signal to eval
            if (state.shadow.pendingSignal) {
                state.shadow.pendingEval = state.shadow.pendingSignal;
                state.shadow.pendingSignal = null;
            }
            
            updateShadowUI();
        }
        
        function checkAutopilot(lastWon) {
            if (!state.autopilot.enabled) return;
            
            const diff = state.shadow.diff;
            const exitThreshold = state.autopilot.exitThreshold;
            const entryThreshold = -Math.abs(state.autopilot.entryThreshold);
            
            // Only exit after a WIN (at Level 0)
            if (state.isRunning && !state.autopilot.isPaused) {
                // Check exit condition: diff too high AND we just won (clean exit)
                if (diff >= exitThreshold && lastWon && state.martingaleLevel === 0) {
                    // Autopilot PAUSE - conditions bad
                    state.autopilot.isPaused = true;
                    state.autopilot.pauseReason = `Diff +${diff} (‚â• +${exitThreshold})`;
                    stopBot();
                    
                    // Switch to watch mode
                    state.isWatching = true;
                    document.getElementById('btnWatch').style.display = 'none';
                    document.getElementById('btnStopWatch').style.display = 'block';
                    
                    log('system', `‚è∏Ô∏è AUTOPILOT: Paused trading - ${state.autopilot.pauseReason}`);
                    log('info', 'Switched to Watch mode. Waiting for correction...');
                    updateAutopilotUI();
                }
            }
            
            // Check entry condition (can be from paused state OR from watch mode)
            if ((state.autopilot.isPaused || state.isWatching) && diff <= entryThreshold) {
                // Autopilot RESUME - conditions good
                state.autopilot.isPaused = false;
                state.autopilot.pauseReason = '';
                
                // Stop watch mode if active
                if (state.isWatching) {
                    state.isWatching = false;
                    document.getElementById('btnWatch').style.display = 'none';
                    document.getElementById('btnStopWatch').style.display = 'none';
                }
                
                log('system', `‚ñ∂Ô∏è AUTOPILOT: Resuming trading - Diff ${diff} (‚â§ ${entryThreshold})`);
                log('info', 'Recovery zone detected. Re-entering market.');
                startBot();
                updateAutopilotUI();
            }
        }
        
        function checkAdaptiveTrigger() {
            if (!state.shadow.adaptiveTrigger.enabled) return;
            
            const history = state.shadow.streakHistory;
            const window = state.shadow.adaptiveTrigger.checkWindow;
            const maxRate = state.shadow.adaptiveTrigger.maxStreakRate;
            const currentTrigger = state.shadow.adaptiveTrigger.currentTrigger;
            const maxTrigger = state.shadow.adaptiveTrigger.maxTrigger;
            
            // Need at least 20 cycles to evaluate
            if (history.length < 20) return;
            
            // Calculate 4+ streak rate in recent cycles
            const recentCycles = history.slice(-Math.min(history.length, window));
            const fourPlusCount = recentCycles.filter(s => s >= 4).length;
            const streakRate = (fourPlusCount / recentCycles.length) * 100;
            
            // If rate exceeds threshold, increase trigger
            if (streakRate > maxRate && currentTrigger < maxTrigger) {
                const oldTrigger = currentTrigger;
                state.shadow.adaptiveTrigger.currentTrigger++;
                state.shadow.adaptiveTrigger.adjustments++;
                
                // Update actual config
                state.config.consecutiveTrigger = state.shadow.adaptiveTrigger.currentTrigger;
                document.getElementById('consecutiveTrigger').value = state.shadow.adaptiveTrigger.currentTrigger;
                
                log('system', `üîß ADAPTIVE: Trigger increased ${oldTrigger} ‚Üí ${state.shadow.adaptiveTrigger.currentTrigger}`);
                log('info', `Reason: 4+ streak rate ${streakRate.toFixed(1)}% > ${maxRate}% threshold`);
                log('info', `Adjustments made: ${state.shadow.adaptiveTrigger.adjustments}`);
                
                // Reset streak history after adjustment to give new trigger a fresh evaluation
                state.shadow.streakHistory = [];
                state.shadow.fourPlusStreaks = 0;
                state.shadow.cyclesCompleted = 0;
            }
            
            updateAdaptiveTriggerUI();
        }
        
        function updateStreakUI() {
            document.getElementById('currentLossStreak').textContent = state.shadow.currentLossStreak;
            document.getElementById('maxLossStreak').textContent = state.shadow.maxLossStreak;
            document.getElementById('cyclesCompleted').textContent = state.shadow.cyclesCompleted;
            document.getElementById('fourPlusStreaks').textContent = state.shadow.fourPlusStreaks;
            
            // Calculate streak rate
            const rate = state.shadow.cyclesCompleted > 0 
                ? ((state.shadow.fourPlusStreaks / state.shadow.cyclesCompleted) * 100).toFixed(1)
                : '0.0';
            
            const rateEl = document.getElementById('streakRate');
            rateEl.textContent = rate + '%';
            
            // Color code the rate
            if (parseFloat(rate) > 5) {
                rateEl.style.color = 'var(--accent-red)';
            } else if (parseFloat(rate) > 3) {
                rateEl.style.color = 'var(--accent-yellow)';
            } else {
                rateEl.style.color = 'var(--accent-green)';
            }
            
            // Color current streak
            const currentStreakEl = document.getElementById('currentLossStreak');
            if (state.shadow.currentLossStreak >= 4) {
                currentStreakEl.style.color = 'var(--accent-red)';
            } else if (state.shadow.currentLossStreak >= 2) {
                currentStreakEl.style.color = 'var(--accent-yellow)';
            } else {
                currentStreakEl.style.color = 'var(--text-primary)';
            }
        }
        
        function updateAdaptiveTriggerUI() {
            const statusEl = document.getElementById('adaptiveTriggerStatus');
            const triggerDisplay = document.getElementById('currentTriggerDisplay');
            const adaptive = state.shadow.adaptiveTrigger;
            
            triggerDisplay.textContent = adaptive.currentTrigger;
            
            if (!adaptive.enabled) {
                statusEl.style.background = 'var(--bg-tertiary)';
                statusEl.style.color = 'var(--text-dim)';
                statusEl.innerHTML = `Adaptive: OFF | Trigger: <span id="currentTriggerDisplay">${state.config.consecutiveTrigger}</span>`;
            } else {
                statusEl.style.background = 'rgba(139, 92, 246, 0.2)';
                statusEl.style.color = 'var(--accent-purple)';
                statusEl.innerHTML = `Adaptive: ON | Trigger: <span style="font-weight:700;">${adaptive.currentTrigger}</span> | Adjustments: ${adaptive.adjustments}`;
            }
        }
        
        function updateShadowUI() {
            document.getElementById('shadowWins').textContent = state.shadow.wins;
            document.getElementById('shadowLosses').textContent = state.shadow.losses;
            
            const diffEl = document.getElementById('shadowDiff');
            diffEl.textContent = (state.shadow.diff >= 0 ? '+' : '') + state.shadow.diff;
            diffEl.style.color = state.shadow.diff >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            
            const lastSignalEl = document.getElementById('shadowLastSignal');
            if (state.shadow.lastSignal) {
                lastSignalEl.textContent = state.shadow.lastSignal.toUpperCase();
                lastSignalEl.style.color = state.shadow.lastSignal === 'over' ? 'var(--accent-green)' : 'var(--accent-red)';
            }
            
            const lastResultEl = document.getElementById('shadowLastResult');
            if (state.shadow.lastResult) {
                lastResultEl.textContent = state.shadow.lastResult;
                lastResultEl.style.color = state.shadow.lastResult.includes('WON') ? 'var(--accent-green)' : 'var(--accent-red)';
            }
            
            // Update recommendation
            const diff = state.shadow.diff;
            const exitThreshold = state.autopilot.exitThreshold;
            const entryThreshold = -Math.abs(state.autopilot.entryThreshold);
            
            const recBox = document.getElementById('shadowRecommendation');
            const recText = document.getElementById('shadowRecommendText');
            
            if (diff >= exitThreshold) {
                recBox.style.background = 'rgba(239, 68, 68, 0.2)';
                recBox.style.border = '1px solid var(--accent-red)';
                recText.textContent = 'üî¥ STAY OUT / EXIT';
                recText.style.color = 'var(--accent-red)';
            } else if (diff <= entryThreshold) {
                recBox.style.background = 'rgba(16, 185, 129, 0.2)';
                recBox.style.border = '1px solid var(--accent-green)';
                recText.textContent = 'üü¢ GOOD TO ENTER';
                recText.style.color = 'var(--accent-green)';
            } else if (diff > 0) {
                recBox.style.background = 'rgba(245, 158, 11, 0.2)';
                recBox.style.border = '1px solid var(--accent-yellow)';
                recText.textContent = 'üü° CAUTION';
                recText.style.color = 'var(--accent-yellow)';
            } else {
                recBox.style.background = 'var(--bg-tertiary)';
                recBox.style.border = '1px solid var(--border-color)';
                recText.textContent = '‚ö™ NEUTRAL';
                recText.style.color = 'var(--text-secondary)';
            }
            
            // Update streak UI
            updateStreakUI();
            updateAdaptiveTriggerUI();
            updateAutopilotUI();
        }
        
        function updateAutopilotUI() {
            const statusEl = document.getElementById('autopilotStatus');
            
            if (!state.autopilot.enabled) {
                statusEl.textContent = 'Autopilot Disabled';
                statusEl.style.background = 'var(--bg-tertiary)';
                statusEl.style.color = 'var(--text-dim)';
            } else if (state.autopilot.isPaused) {
                statusEl.textContent = `‚è∏Ô∏è Paused: ${state.autopilot.pauseReason}`;
                statusEl.style.background = 'rgba(239, 68, 68, 0.2)';
                statusEl.style.color = 'var(--accent-red)';
            } else if (state.isRunning) {
                statusEl.textContent = '‚ñ∂Ô∏è Active - Monitoring...';
                statusEl.style.background = 'rgba(16, 185, 129, 0.2)';
                statusEl.style.color = 'var(--accent-green)';
            } else {
                statusEl.textContent = '‚èπÔ∏è Ready - Start bot to activate';
                statusEl.style.background = 'rgba(59, 130, 246, 0.2)';
                statusEl.style.color = 'var(--accent-blue)';
            }
        }
        
        function resetShadow() {
            state.shadow.wins = 0;
            state.shadow.losses = 0;
            state.shadow.diff = 0;
            state.shadow.consecutiveLow = 0;
            state.shadow.consecutiveHigh = 0;
            state.shadow.lastSignal = null;
            state.shadow.lastResult = null;
            state.shadow.inSimRecovery = false;
            state.shadow.simDirection = null;
            state.shadow.simLevel = 0;
            state.shadow.history = [];
            state.shadow.pendingSignal = null;
            state.shadow.pendingEval = null;
            
            // Reset streak tracking
            state.shadow.currentLossStreak = 0;
            state.shadow.maxLossStreak = 0;
            state.shadow.cyclesCompleted = 0;
            state.shadow.fourPlusStreaks = 0;
            state.shadow.streakHistory = [];
            
            // Reset adaptive trigger to base (but keep enabled state)
            state.shadow.adaptiveTrigger.currentTrigger = state.shadow.adaptiveTrigger.baseTrigger;
            state.shadow.adaptiveTrigger.adjustments = 0;
            state.config.consecutiveTrigger = state.shadow.adaptiveTrigger.baseTrigger;
            document.getElementById('consecutiveTrigger').value = state.shadow.adaptiveTrigger.baseTrigger;
            
            // Also reset autopilot pause state
            state.autopilot.isPaused = false;
            state.autopilot.pauseReason = '';
            
            updateShadowUI();
            log('system', 'Shadow tracker reset');
        }

        // ========================================
        // TRADING LOGIC
        // ========================================
        function processTrading(digit) {
            const observationCount = Math.min(state.digits.length, state.config.observationTicks);
            
            switch (state.phase) {
                case 'observation':
                    // Still collecting data
                    updateObservationProgress(observationCount);
                    
                    if (observationCount >= state.config.observationTicks) {
                        state.phase = 'analyzing';
                        setPhase('analyzing');
                        log('info', 'Observation complete, analyzing patterns...');
                    }
                    break;
                    
                case 'analyzing':
                    // Look for entry signal
                    const signal = analyzePattern();
                    if (signal) {
                        state.currentDirection = signal.direction;
                        state.phase = 'trading';
                        setPhase('trading');
                        updateSignalDisplay(signal);
                        log('signal', `Entry signal: ${signal.direction.toUpperCase()} (confidence: ${signal.confidence}%)`);
                        placeTrade();
                    }
                    break;
                    
                case 'trading':
                case 'recovery':
                    // Wait for contract result
                    break;
            }
        }
        
        function analyzePattern() {
            const trigger = state.config.consecutiveTrigger;
            const strategy = state.config.strategy;
            
            // Calculate recent bias
            const recentDigits = state.digits.slice(-50);
            const lowCount = recentDigits.filter(d => d <= 4).length;
            const highCount = recentDigits.length - lowCount;
            const lowPercent = (lowCount / recentDigits.length) * 100;
            const highPercent = (highCount / recentDigits.length) * 100;
            
            let signal = null;
            
            if (strategy === 'reversal') {
                // Wait for consecutive pattern, then bet on reversal
                if (state.consecutiveLow >= trigger) {
                    signal = {
                        direction: 'over',
                        confidence: Math.min(50 + (state.consecutiveLow - trigger + 1) * 10, 85),
                        reason: `${state.consecutiveLow} consecutive low digits`
                    };
                } else if (state.consecutiveHigh >= trigger) {
                    signal = {
                        direction: 'under',
                        confidence: Math.min(50 + (state.consecutiveHigh - trigger + 1) * 10, 85),
                        reason: `${state.consecutiveHigh} consecutive high digits`
                    };
                }
            } else {
                // Trend following
                if (state.consecutiveLow >= trigger) {
                    signal = {
                        direction: 'under',
                        confidence: Math.min(50 + (lowPercent - 50) * 2, 75),
                        reason: `Trend: ${state.consecutiveLow} consecutive lows`
                    };
                } else if (state.consecutiveHigh >= trigger) {
                    signal = {
                        direction: 'over',
                        confidence: Math.min(50 + (highPercent - 50) * 2, 75),
                        reason: `Trend: ${state.consecutiveHigh} consecutive highs`
                    };
                }
            }
            
            return signal;
        }
        
        function placeTrade() {
            const stake = calculateStake();
            const barrier = state.currentDirection === 'over' ? '4' : '5';
            const contractType = state.currentDirection === 'over' ? 'DIGITOVER' : 'DIGITUNDER';
            
            state.pendingTrade = {
                direction: state.currentDirection,
                stake: stake,
                level: state.martingaleLevel,
                timestamp: new Date().toISOString()
            };
            
            log('trade', `Placing ${state.currentDirection.toUpperCase()} trade - Stake: $${stake.toFixed(2)} (Level ${state.martingaleLevel})`);
            
            send({
                buy: 1,
                price: stake,
                parameters: {
                    contract_type: contractType,
                    symbol: state.config.market,
                    duration: 1,
                    duration_unit: 't',
                    basis: 'stake',
                    amount: stake,
                    currency: 'USD',
                    barrier: barrier
                }
            });
            
            elements.currentStake.textContent = `$${stake.toFixed(2)}`;
        }
        
        function calculateStake() {
            const multiplier = 100 / state.config.payout; // ~1.053 for 95% payout
            const adjustedMultiplier = multiplier + 0.05; // Add buffer for profit
            return parseFloat((state.config.baseStake * Math.pow(adjustedMultiplier * 2, state.martingaleLevel)).toFixed(2));
        }
        
        function handleBuyResponse(data) {
            if (data.buy) {
                state.currentContractId = data.buy.contract_id;
                log('info', `Contract opened: ${state.currentContractId}`);
                
                // Subscribe to contract updates
                send({
                    proposal_open_contract: 1,
                    contract_id: state.currentContractId,
                    subscribe: 1
                });
            }
        }
        
        function handleContractUpdate(contract) {
            if (contract.is_sold) {
                const won = contract.status === 'won';
                const profit = parseFloat(contract.profit);
                
                processTrade(won, profit, contract);
            }
        }
        
        function processTrade(won, profit, contract) {
            state.totalTrades++;
            state.profitLoss += profit;
            
            const trade = {
                ...state.pendingTrade,
                won,
                profit,
                balance: state.profitLoss,
                contractId: contract?.contract_id,
                timestamp: new Date().toISOString()
            };
            
            state.trades.push(trade);
            saveToDB('trades', trade);
            saveState();
            
            if (won) {
                state.wins++;
                log('trade', `WIN! Profit: $${profit.toFixed(2)} | Total: $${state.profitLoss.toFixed(2)}`);
                
                // Reset martingale and go back to analyzing
                state.martingaleLevel = 0;
                state.phase = 'analyzing';
                setPhase('analyzing');
                updateMartingaleHighlight();
            } else {
                state.losses++;
                log('loss', `LOSS! Loss: $${profit.toFixed(2)} | Total: $${state.profitLoss.toFixed(2)}`);
                
                // Check if max depth reached
                if (state.martingaleLevel >= state.config.maxDepth - 1) {
                    log('system', 'Max martingale depth reached! Resetting...');
                    state.martingaleLevel = 0;
                    state.phase = 'analyzing';
                    setPhase('analyzing');
                } else {
                    // Continue martingale recovery
                    state.martingaleLevel++;
                    state.phase = 'recovery';
                    setPhase('recovery');
                    updateMartingaleHighlight();
                    
                    // Place recovery trade immediately
                    setTimeout(() => {
                        if (state.isRunning && state.phase === 'recovery') {
                            placeTrade();
                        }
                    }, 500);
                }
            }
            
            // Check stop loss / take profit
            if (state.config.stopLoss > 0 && state.profitLoss <= -state.config.stopLoss) {
                log('system', `Stop loss hit! Stopping bot.`);
                stopBot();
            }
            
            if (state.config.takeProfit > 0 && state.profitLoss >= state.config.takeProfit) {
                log('system', `Take profit hit! Stopping bot.`);
                stopBot();
            }
            
            // Check autopilot exit conditions (after a win at Level 0)
            if (won && state.martingaleLevel === 0 && state.autopilot.enabled) {
                const diff = state.shadow.diff;
                if (diff >= state.autopilot.exitThreshold) {
                    state.autopilot.isPaused = true;
                    state.autopilot.pauseReason = `Diff +${diff} (‚â• +${state.autopilot.exitThreshold})`;
                    log('system', `‚è∏Ô∏è AUTOPILOT: Paused trading - ${state.autopilot.pauseReason}`);
                    log('info', 'Shadow tracker shows correction likely. Taking cooldown.');
                    stopBot();
                }
            }
            
            updateStats();
            updateTradeHistory(trade);
        }

        // ========================================
        // UI UPDATES
        // ========================================
        function updateTickDisplay(price, digit) {
            elements.tickPrice.textContent = price.toFixed(5);
            elements.currentDigit.textContent = digit;
            elements.currentDigit.className = 'current-digit ' + (digit <= 4 ? 'low' : 'high');
            elements.tickCount.textContent = state.ticks.length;
        }
        
        function updateDigitDistribution() {
            const total = state.digits.length || 1;
            let html = '';
            
            for (let i = 0; i < 10; i++) {
                const percent = (state.digitCounts[i] / total * 100);
                const heightPercent = Math.min(percent * 5, 100);
                const colorClass = i <= 4 ? 'low' : 'high';
                
                html += `
                    <div class="digit-bar">
                        <div class="digit-bar-fill">
                            <div class="digit-bar-inner ${colorClass}" style="height: ${heightPercent}%"></div>
                        </div>
                        <div class="digit-label">${i}</div>
                        <div class="digit-percent">${percent.toFixed(1)}%</div>
                    </div>
                `;
            }
            
            elements.digitDistribution.innerHTML = html;
        }
        
        function updateRecentDigits() {
            const recent = state.digits.slice(-30);
            let html = '';
            
            recent.forEach(d => {
                const colorClass = d <= 4 ? 'low' : 'high';
                html += `<div class="recent-digit ${colorClass}">${d}</div>`;
            });
            
            elements.recentDigits.innerHTML = html;
        }
        
        function updateTrendIndicators() {
            const recent = state.digits.slice(-100);
            const lowCount = recent.filter(d => d <= 4).length;
            const highCount = recent.length - lowCount;
            const total = recent.length || 1;
            
            elements.lowPercent.textContent = `${(lowCount / total * 100).toFixed(1)}%`;
            elements.highPercent.textContent = `${(highCount / total * 100).toFixed(1)}%`;
            elements.consecutiveLow.textContent = state.consecutiveLow;
            elements.consecutiveHigh.textContent = state.consecutiveHigh;
        }
        
        function updateObservationProgress(count) {
            const target = state.config.observationTicks;
            const percent = Math.min((count / target) * 100, 100);
            
            elements.observationProgress.textContent = `${count} / ${target}`;
            elements.progressFill.style.width = `${percent}%`;
        }
        
        function updateSignalDisplay(signal) {
            if (signal) {
                elements.signalDirection.textContent = signal.direction.toUpperCase();
                elements.signalDirection.className = `signal-direction ${signal.direction}`;
                elements.signalConfidence.textContent = signal.reason;
            } else {
                elements.signalDirection.textContent = 'WAITING';
                elements.signalDirection.className = 'signal-direction none';
                elements.signalConfidence.textContent = 'Analyzing patterns...';
            }
        }
        
        function updateStats() {
            elements.totalTrades.textContent = state.totalTrades;
            elements.wins.textContent = state.wins;
            elements.losses.textContent = state.losses;
            elements.winRate.textContent = state.totalTrades > 0 
                ? `${(state.wins / state.totalTrades * 100).toFixed(1)}%` 
                : '0%';
            
            const pl = state.profitLoss;
            elements.profitLoss.textContent = `$${pl >= 0 ? '' : ''}${pl.toFixed(2)}`;
            elements.profitLoss.className = `stat-value ${pl >= 0 ? 'profit' : 'loss'}`;
        }
        
        function updateMartingaleTable() {
            const baseStake = state.config.baseStake;
            const payout = state.config.payout / 100;
            const maxDepth = state.config.maxDepth;
            const multiplier = (100 / state.config.payout) + 0.05;
            
            let html = '';
            let totalRisk = 0;
            
            for (let i = 0; i < maxDepth; i++) {
                const stake = parseFloat((baseStake * Math.pow(multiplier * 2, i)).toFixed(2));
                totalRisk += stake;
                const winProfit = stake * payout - totalRisk + stake;
                
                html += `
                    <tr data-level="${i}">
                        <td>${i + 1}</td>
                        <td>$${stake.toFixed(2)}</td>
                        <td>$${totalRisk.toFixed(2)}</td>
                        <td>$${winProfit.toFixed(2)}</td>
                    </tr>
                `;
            }
            
            elements.martingaleBody.innerHTML = html;
            elements.maxRisk.textContent = `$${totalRisk.toFixed(2)}`;
            elements.currentStake.textContent = `$${baseStake.toFixed(2)}`;
        }
        
        function updateMartingaleHighlight() {
            const rows = elements.martingaleBody.querySelectorAll('tr');
            rows.forEach((row, i) => {
                row.classList.toggle('active', i === state.martingaleLevel);
            });
            elements.currentLevel.textContent = state.martingaleLevel;
        }
        
        function updateTradeHistory(trade) {
            if (state.trades.length === 1) {
                elements.tradeHistory.innerHTML = '';
            }
            
            const entry = document.createElement('div');
            entry.className = `trade-entry ${trade.won ? 'win' : 'loss'}`;
            entry.innerHTML = `
                <span>${trade.direction.toUpperCase()} L${trade.level + 1}</span>
                <span>${trade.won ? '+' : ''}$${trade.profit.toFixed(2)}</span>
            `;
            
            elements.tradeHistory.insertBefore(entry, elements.tradeHistory.firstChild);
            
            // Keep only last 50 in DOM
            while (elements.tradeHistory.children.length > 50) {
                elements.tradeHistory.removeChild(elements.tradeHistory.lastChild);
            }
        }
        
        function setPhase(phase) {
            state.phase = phase;
            const badge = elements.phaseBadge;
            badge.className = `phase-badge ${phase}`;
            badge.textContent = phase.toUpperCase();
        }

        // ========================================
        // BOT CONTROLS
        // ========================================
        function startBot() {
            // Read config
            state.config.apiToken = document.getElementById('apiToken').value;
            state.config.market = document.getElementById('market').value;
            state.config.baseStake = parseFloat(document.getElementById('baseStake').value);
            state.config.payout = parseFloat(document.getElementById('payout').value);
            state.config.maxDepth = parseInt(document.getElementById('maxDepth').value);
            state.config.observationTicks = parseInt(document.getElementById('observationTicks').value);
            state.config.consecutiveTrigger = parseInt(document.getElementById('consecutiveTrigger').value);
            state.config.stopLoss = parseFloat(document.getElementById('stopLoss').value) || 0;
            state.config.takeProfit = parseFloat(document.getElementById('takeProfit').value) || 0;
            
            if (!state.config.apiToken) {
                log('system', 'Please enter your API token');
                return;
            }
            
            // Update autopilot thresholds
            state.autopilot.exitThreshold = parseInt(document.getElementById('exitThreshold').value);
            state.autopilot.entryThreshold = parseInt(document.getElementById('entryThreshold').value);
            
            state.isRunning = true;
            state.phase = 'observation';
            state.martingaleLevel = 0;
            
            // Reset shadow tracker for new session (if not resuming from autopilot)
            if (!state.autopilot.isPaused && !state.isWatching) {
                resetShadow();
            }
            state.autopilot.isPaused = false;
            state.isWatching = false;
            
            setPhase('observation');
            updateMartingaleTable();
            updateMartingaleHighlight();
            updateAutopilotUI();
            
            elements.btnStart.style.display = 'none';
            elements.btnStop.style.display = 'block';
            document.getElementById('btnWatch').style.display = 'none';
            document.getElementById('btnStopWatch').style.display = 'none';
            
            log('system', 'Bot started');
            log('info', `Strategy: ${state.config.strategy} | Trigger: ${state.config.consecutiveTrigger} consec.`);
            log('info', `Base stake: $${state.config.baseStake} | Max depth: ${state.config.maxDepth}`);
            
            if (state.autopilot.enabled) {
                log('info', `ü§ñ Autopilot: Exit at +${state.autopilot.exitThreshold}, Enter at -${state.autopilot.entryThreshold}`);
            }
            
            if (!state.connected) {
                connect();
            } else {
                subscribeToTicks();
            }
            
            // Request wake lock
            requestWakeLock();
        }
        
        function stopBot() {
            state.isRunning = false;
            state.phase = 'idle';
            setPhase('idle');
            
            elements.btnStart.style.display = 'block';
            elements.btnStop.style.display = 'none';
            
            // Show watch button unless autopilot switched to watch mode
            if (!state.isWatching) {
                document.getElementById('btnWatch').style.display = 'block';
                document.getElementById('btnStopWatch').style.display = 'none';
            }
            
            log('system', 'Bot stopped');
            saveState();
            updateAutopilotUI();
        }

        // ========================================
        // WAKE LOCK API
        // ========================================
        let wakeLock = null;
        
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    log('system', 'Wake lock acquired');
                    
                    wakeLock.addEventListener('release', () => {
                        log('system', 'Wake lock released');
                    });
                }
            } catch (err) {
                log('system', `Wake lock failed: ${err.message}`);
            }
        }
        
        // Re-acquire wake lock on visibility change
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && state.isRunning) {
                await requestWakeLock();
                
                // Check connection
                if (!state.connected) {
                    log('system', 'Page visible, reconnecting...');
                    connect();
                }
            }
        });

        // ========================================
        // CSV EXPORT
        // ========================================
        function exportCSV(data, filename, headers) {
            const csv = [
                headers.join(','),
                ...data.map(row => headers.map(h => {
                    const val = row[h.toLowerCase().replace(/ /g, '')];
                    return typeof val === 'string' && val.includes(',') ? `"${val}"` : val;
                }).join(','))
            ].join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        document.getElementById('btnExportTicks').addEventListener('click', () => {
            const headers = ['timestamp', 'price', 'digit', 'epoch'];
            exportCSV(state.ticks, `ticks_${Date.now()}.csv`, headers);
            log('system', `Exported ${state.ticks.length} ticks`);
        });
        
        document.getElementById('btnExportTrades').addEventListener('click', () => {
            const headers = ['timestamp', 'direction', 'stake', 'level', 'won', 'profit', 'balance'];
            exportCSV(state.trades, `trades_${Date.now()}.csv`, headers);
            log('system', `Exported ${state.trades.length} trades`);
        });
        
        document.getElementById('btnExportLog').addEventListener('click', () => {
            const headers = ['timestamp', 'type', 'message'];
            exportCSV(state.activityLog, `log_${Date.now()}.csv`, headers);
            log('system', `Exported ${state.activityLog.length} log entries`);
        });

        // ========================================
        // EVENT LISTENERS
        // ========================================
        elements.btnStart.addEventListener('click', startBot);
        elements.btnStop.addEventListener('click', stopBot);
        
        // Watch only mode
        document.getElementById('btnWatch').addEventListener('click', startWatching);
        document.getElementById('btnStopWatch').addEventListener('click', stopWatching);
        
        function startWatching() {
            state.config.apiToken = document.getElementById('apiToken').value;
            state.config.market = document.getElementById('market').value;
            state.config.observationTicks = parseInt(document.getElementById('observationTicks').value);
            state.config.consecutiveTrigger = parseInt(document.getElementById('consecutiveTrigger').value);
            
            if (!state.config.apiToken) {
                log('system', 'Please enter your API token');
                return;
            }
            
            state.isWatching = true;
            resetShadow();
            
            document.getElementById('btnWatch').style.display = 'none';
            document.getElementById('btnStopWatch').style.display = 'block';
            document.getElementById('btnStart').style.display = 'none';
            
            log('system', 'üëÅ Watch Only mode started');
            log('info', 'Shadow tracker active. Bot will NOT trade.');
            log('info', 'Use this to monitor conditions before entering.');
            
            if (!state.connected) {
                connect();
            } else {
                subscribeToTicks();
            }
        }
        
        function stopWatching() {
            state.isWatching = false;
            
            document.getElementById('btnWatch').style.display = 'block';
            document.getElementById('btnStopWatch').style.display = 'none';
            document.getElementById('btnStart').style.display = 'block';
            
            log('system', 'üëÅ Watch Only mode stopped');
        }
        
        document.getElementById('btnClearLog').addEventListener('click', () => {
            elements.logContainer.innerHTML = '';
            state.activityLog = [];
            log('system', 'Log cleared');
        });
        
        // Strategy toggle
        document.querySelectorAll('.strategy-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.strategy-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.config.strategy = btn.dataset.strategy;
                log('info', `Strategy changed to: ${state.config.strategy}`);
            });
        });
        
        // Update martingale table on config change
        ['baseStake', 'payout', 'maxDepth'].forEach(id => {
            document.getElementById(id).addEventListener('change', updateMartingaleTable);
        });
        
        // Sync consecutive trigger with adaptive trigger
        document.getElementById('consecutiveTrigger').addEventListener('change', (e) => {
            const newTrigger = parseInt(e.target.value);
            state.config.consecutiveTrigger = newTrigger;
            
            // Update adaptive trigger base if not enabled
            if (!state.shadow.adaptiveTrigger.enabled) {
                state.shadow.adaptiveTrigger.baseTrigger = newTrigger;
                state.shadow.adaptiveTrigger.currentTrigger = newTrigger;
            }
            
            updateAdaptiveTriggerUI();
        });
        
        // Shadow Tracker controls
        document.getElementById('shadowEnabled').addEventListener('change', (e) => {
            state.shadow.enabled = e.target.checked;
            log('info', `Shadow tracker ${e.target.checked ? 'enabled' : 'disabled'}`);
        });
        
        document.getElementById('btnResetShadow').addEventListener('click', resetShadow);
        
        // Autopilot controls
        document.getElementById('autopilotEnabled').addEventListener('change', (e) => {
            state.autopilot.enabled = e.target.checked;
            if (e.target.checked) {
                state.autopilot.exitThreshold = parseInt(document.getElementById('exitThreshold').value);
                state.autopilot.entryThreshold = parseInt(document.getElementById('entryThreshold').value);
                log('system', `ü§ñ AUTOPILOT ENABLED - Exit at +${state.autopilot.exitThreshold}, Enter at -${state.autopilot.entryThreshold}`);
            } else {
                state.autopilot.isPaused = false;
                log('system', 'ü§ñ AUTOPILOT DISABLED');
            }
            updateAutopilotUI();
        });
        
        document.getElementById('exitThreshold').addEventListener('change', (e) => {
            state.autopilot.exitThreshold = parseInt(e.target.value);
            if (state.autopilot.enabled) {
                log('info', `Autopilot exit threshold updated to +${e.target.value}`);
            }
            updateShadowUI();
        });
        
        document.getElementById('entryThreshold').addEventListener('change', (e) => {
            state.autopilot.entryThreshold = parseInt(e.target.value);
            if (state.autopilot.enabled) {
                log('info', `Autopilot entry threshold updated to -${e.target.value}`);
            }
            updateShadowUI();
        });
        
        // Adaptive Trigger controls
        document.getElementById('adaptiveTriggerEnabled').addEventListener('change', (e) => {
            state.shadow.adaptiveTrigger.enabled = e.target.checked;
            
            if (e.target.checked) {
                // Store current trigger as base
                state.shadow.adaptiveTrigger.baseTrigger = parseInt(document.getElementById('consecutiveTrigger').value);
                state.shadow.adaptiveTrigger.currentTrigger = state.shadow.adaptiveTrigger.baseTrigger;
                state.shadow.adaptiveTrigger.adjustments = 0;
                
                // Reset streak history to start fresh evaluation
                state.shadow.streakHistory = [];
                state.shadow.fourPlusStreaks = 0;
                state.shadow.cyclesCompleted = 0;
                
                log('system', `üîß ADAPTIVE TRIGGER ENABLED - Base: ${state.shadow.adaptiveTrigger.baseTrigger}, Max: ${state.shadow.adaptiveTrigger.maxTrigger}`);
                log('info', `Will increase trigger if 4+ loss streak rate exceeds 3%`);
            } else {
                log('system', 'üîß ADAPTIVE TRIGGER DISABLED');
            }
            
            updateAdaptiveTriggerUI();
        });

        // ========================================
        // INITIALIZATION
        // ========================================
        async function init() {
            await initDB();
            
            // Initialize digit distribution display
            for (let i = 0; i < 10; i++) {
                state.digitCounts[i] = 0;
            }
            updateDigitDistribution();
            updateMartingaleTable();
            updateShadowUI();
            updateStreakUI();
            updateAdaptiveTriggerUI();
            updateAutopilotUI();
            
            log('system', 'Hybrid Martingale Bot initialized');
            log('info', 'Enter your API token and click Start to begin');
            log('info', 'üí° Shadow Tracker will monitor market even when bot is off');
            log('info', 'üí° Enable Adaptive Trigger to auto-adjust based on loss streaks');
        }
        
        init();
    </script>
</body>
</html>
